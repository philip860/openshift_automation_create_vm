---
# 1) PREFLIGHT (runs in --check)
- name: Preflight | Verify API server reachable (list default Namespace)
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: v1
    kind: Namespace
    name: default
  register: api_check

- name: Preflight | Verify KubeVirt VirtualMachine CRD exists
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    name: virtualmachines.kubevirt.io
  register: crd_vm

- name: Preflight | Verify CDI DataVolume CRD exists
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    name: datavolumes.cdi.kubevirt.io
  register: crd_dv

- name: Preflight | Fail if required CRDs missing
  ansible.builtin.assert:
    that:
      - crd_vm.resources | length > 0
      - crd_dv.resources | length > 0
    fail_msg: >
      Required CRDs missing. Install OpenShift Virtualization (KubeVirt) and CDI.

- name: Preflight | If StorageClass set, ensure it exists
  when: storage_class | length > 0
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: storage.k8s.io/v1
    kind: StorageClass
    name: "{{ storage_class }}"
  register: sc_info

- name: Preflight | Fail if specified StorageClass not found
  when: storage_class | length > 0
  ansible.builtin.assert:
    that:
      - sc_info.resources | length > 0
    fail_msg: "StorageClass '{{ storage_class }}' not found."

- name: Preflight | Validate image_url basic format
  ansible.builtin.assert:
    that:
      - image_url is match('^https?://.+')
    fail_msg: "image_url must be HTTP/HTTPS."

- name: Preflight | HEAD check the image_url to avoid CDI retry loops
  when: not ansible_check_mode
  ansible.builtin.uri:
    url: "{{ image_url }}"
    method: HEAD
    return_content: false
    validate_certs: true
    timeout: 30
  register: image_head
  failed_when: image_head.status not in [200]

# 2) PLAN (only in --check)
- name: Plan | Show intended objects (no changes)
  when: ansible_check_mode
  ansible.builtin.debug:
    msg:
      - "Would ensure Namespace '{{ namespace }}' exists."
      - "Would create VM '{{ vm_name }}' with {{ cpu_cores }} vCPU, {{ memory }} RAM."
      - "Would create DataVolume '{{ vm_name }}-rootdisk' size {{ disk_size }}, SC='{{ storage_class | default('default', true) }}', mode='{{ volume_mode | default('unspecified', true) }}'."
      - "Would import image from '{{ image_url }}'. RunStrategy='{{ run_strategy }}'."
      - "SSH key present? {{ (ssh_public_key | length > 0) | ternary('yes','no') }}; password auth: {{ ssh_password_auth }}."

# 3) CREATE/APPLY (skipped in --check)
- name: Create | Ensure target Namespace exists
  when: not ansible_check_mode
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig }}"
    api_version: v1
    kind: Namespace
    name: "{{ namespace }}"
    state: present

- name: Create | Define/Apply VirtualMachine with DataVolumeTemplate
  when: not ansible_check_mode
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig }}"
    namespace: "{{ namespace }}"
    state: present
    definition:
      apiVersion: kubevirt.io/v1
      kind: VirtualMachine
      metadata:
        name: "{{ vm_name }}"
        labels: { app: "{{ vm_name }}" }
      spec:
        runStrategy: "{{ run_strategy }}"
        dataVolumeTemplates:
          - metadata:
              name: "{{ vm_name }}-rootdisk"
            spec:
              source:
                http: { url: "{{ image_url }}" }
              storage:
                resources:
                  requests:
                    storage: "{{ disk_size }}"
                storageClassName: "{{ (storage_class | length > 0) | ternary(storage_class, omit) }}"
                volumeMode: "{{ (volume_mode | length > 0) | ternary(volume_mode, omit) }}"
                accessModes: [ "ReadWriteOnce" ]
        template:
          metadata:
            labels: { kubevirt.io/domain: "{{ vm_name }}" }
          spec:
            domain:
              cpu:
                cores: "{{ cpu_cores | int }}"
              resources:
                requests:
                  memory: "{{ memory }}"
              devices:
                disks:
                  - name: rootdisk
                    disk: { bus: virtio }
                  - name: cloudinitdisk
                    disk: { bus: virtio }
                interfaces:
                  - name: default
                    masquerade: {}
            networks:
              - name: default
                pod: {}
            volumes:
              - name: rootdisk
                dataVolume: { name: "{{ vm_name }}-rootdisk" }
              - name: cloudinitdisk
                cloudInitNoCloud:
                  userData: |
                    #cloud-config
                    user: cloud-user
                    password: "{{ initial_password }}"
                    chpasswd: { expire: False }
                    ssh_pwauth: {{ ssh_password_auth | bool }}
                    {% if ssh_public_key | length > 0 %}
                    ssh_authorized_keys:
                      - "{{ ssh_public_key }}"
                    {% endif %}
                    package_update: true
                    runcmd:
                      - [ sh, -c, "dnf -y install qemu-guest-agent && systemctl enable --now qemu-guest-agent || true" ]

# 4) WAITS (skipped in --check)
- name: Wait | DataVolume import to complete (Succeeded or Failed)
  when: not ansible_check_mode
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: cdi.kubevirt.io/v1beta1
    kind: DataVolume
    name: "{{ vm_name }}-rootdisk"
    namespace: "{{ namespace }}"
  register: dv
  until: >
    (dv.resources | length) > 0 and
    (dv.resources[0].status is defined) and
    (
      (dv.resources[0].status.phase | default('')) == "Succeeded" or
      (dv.resources[0].status.phase | default('')) == "Failed"
    )
  retries: "{{ dv_wait_retries | int }}"
  delay: "{{ dv_wait_delay | int }}"

- name: Fail | Show CDI import error if DataVolume failed
  when:
    - not ansible_check_mode
    - dv.resources | length > 0
    - (dv.resources[0].status.phase | default('')) == "Failed"
  ansible.builtin.fail:
    msg: >
      DataVolume import failed. Phase={{ dv.resources[0].status.phase | default('') }}.
      Check importer pod logs and PVC events for details.

- name: Wait | VM to reach a runnable state
  when: not ansible_check_mode
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: kubevirt.io/v1
    kind: VirtualMachine
    name: "{{ vm_name }}"
    namespace: "{{ namespace }}"
  register: vm
  until: >
    (vm.resources | length) > 0 and
    (vm.resources[0].status is defined) and
    (vm.resources[0].status.printableStatus | default('')) in ["Running", "Paused", "Provisioning"]
  retries: "{{ vm_wait_retries | int }}"
  delay: "{{ vm_wait_delay | int }}"

# 5) OUTPUT (always)
- name: Output | Summary
  ansible.builtin.debug:
    msg:
      - "Namespace: {{ namespace }}"
      - "VM: {{ vm_name }}"
      - "CPU/Memory: {{ cpu_cores }} cores / {{ memory }}"
      - "Disk: {{ disk_size }} (SC='{{ storage_class | default('default', true) }}', mode='{{ volume_mode | default('unspecified', true) }}')"
      - "Image: {{ image_url }}"
      - "RunStrategy: {{ run_strategy }}"
      - "Note: In --check, no resources were created; see the Plan output."
