---
# This single include file handles:
# 1) Preflight checks (read-only, runs in --check)
# 2) Plan output (only in --check)
# 3) Create/Apply resources (skipped in --check)
# 4) Waits for DataVolume + VM (skipped in --check)
# 5) Final output (runs in all modes)

# -------------------------
# 1) PREFLIGHT / VALIDATIONS
# -------------------------

- name: Preflight | Verify API server is reachable by listing a known Namespace (read-only)
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: v1
    kind: Namespace
    name: default
  register: api_check

- name: Preflight | Verify KubeVirt VirtualMachine CRD exists (read-only)
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    name: virtualmachines.kubevirt.io
  register: crd_vm

- name: Preflight | Verify CDI DataVolume CRD exists (read-only)
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    name: datavolumes.cdi.kubevirt.io
  register: crd_dv

- name: Preflight | Fail early if required CRDs are missing
  ansible.builtin.assert:
    that:
      - crd_vm.resources | length > 0
      - crd_dv.resources | length > 0
    fail_msg: >
      Required CRDs not found. Ensure OpenShift Virtualization (KubeVirt) and CDI are installed
      (virtualmachines.kubevirt.io, datavolumes.cdi.kubevirt.io).

- name: Preflight | If a StorageClass was specified, ensure it exists (read-only)
  when: storage_class | length > 0
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: storage.k8s.io/v1
    kind: StorageClass
    name: "{{ storage_class }}"
  register: sc_info

- name: Preflight | Fail if specified StorageClass does not exist
  when: storage_class | length > 0
  ansible.builtin.assert:
    that:
      - sc_info.resources | length > 0
    fail_msg: "StorageClass '{{ storage_class }}' not found. Set a valid class or leave it empty."

- name: Preflight | Validate image_url format (basic)
  ansible.builtin.assert:
    that:
      - image_url is match('^https?://.+')
    fail_msg: "image_url must be an HTTP/HTTPS URL for CDI import."

# -------------------------
# 2) PLAN (only in --check)
# -------------------------

- name: Plan | Show intended objects and parameters (no changes)
  when: ansible_check_mode
  ansible.builtin.debug:
    msg:
      - "Would ensure Namespace '{{ namespace }}' exists."
      - "Would create/ensure VM '{{ vm_name }}' with {{ cpu_cores }} vCPU, {{ memory }} RAM."
      - "Would provision DataVolume '{{ vm_name }}-rootdisk' = {{ disk_size }}, SC='{{ storage_class | default('default', true) }}', mode='{{ volume_mode | default('unspecified', true) }}'."
      - "Would import image from '{{ image_url }}'."
      - "Would set runStrategy='{{ run_strategy }}'."
      - "Would inject SSH key? {{ (ssh_public_key | length > 0) | ternary('yes','no') }} | SSH password auth: {{ ssh_password_auth }}."

# -------------------------
# 3) CREATE/APPLY (skipped in --check)
# -------------------------

- name: Create | Ensure target Namespace exists
  when: not ansible_check_mode
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig }}"
    api_version: v1
    kind: Namespace
    name: "{{ namespace }}"
    state: present

- name: Create | Define/Apply VirtualMachine with DataVolumeTemplate for CentOS 9
  when: not ansible_check_mode
  kubernetes.core.k8s:
    kubeconfig: "{{ kubeconfig }}"
    namespace: "{{ namespace }}"
    state: present
    definition:
      apiVersion: kubevirt.io/v1
      kind: VirtualMachine
      metadata:
        name: "{{ vm_name }}"
        labels:
          app: "{{ vm_name }}"
      spec:
        runStrategy: "{{ run_strategy }}"
        dataVolumeTemplates:
          - metadata:
              name: "{{ vm_name }}-rootdisk"
            spec:
              source:
                http:
                  url: "{{ image_url }}"
              storage:
                resources:
                  requests:
                    storage: "{{ disk_size }}"
                {% if storage_class | length > 0 %}
                storageClassName: "{{ storage_class }}"
                {% endif %}
                {% if volume_mode | length > 0 %}
                volumeMode: "{{ volume_mode }}"
                {% endif %}
                accessModes:
                  - ReadWriteOnce
        template:
          metadata:
            labels:
              kubevirt.io/domain: "{{ vm_name }}"
          spec:
            domain:
              cpu:
                cores: {{ cpu_cores }}
              resources:
                requests:
                  memory: "{{ memory }}"
              devices:
                disks:
                  - name: rootdisk
                    disk:
                      bus: virtio
                  - name: cloudinitdisk
                    disk:
                      bus: virtio
                interfaces:
                  - name: default
                    masquerade: {}
            networks:
              - name: default
                pod: {}
            volumes:
              - name: rootdisk
                dataVolume:
                  name: "{{ vm_name }}-rootdisk"
              - name: cloudinitdisk
                cloudInitNoCloud:
                  userData: |
                    #cloud-config
                    user: cloud-user
                    password: "{{ initial_password }}"
                    chpasswd: { expire: False }
                    ssh_pwauth: {{ ssh_password_auth | bool }}
                    {% if ssh_public_key | length > 0 %}
                    ssh_authorized_keys:
                      - "{{ ssh_public_key }}"
                    {% endif %}
                    package_update: true
                    runcmd:
                      - [ sh, -c, "dnf -y install qemu-guest-agent && systemctl enable --now qemu-guest-agent || true" ]

# -------------------------
# 4) WAITS (skipped in --check)
# -------------------------

- name: Wait | DataVolume import to complete (root disk ready)
  when: not ansible_check_mode
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: cdi.kubevirt.io/v1beta1
    kind: DataVolume
    name: "{{ vm_name }}-rootdisk"
    namespace: "{{ namespace }}"
  register: dv
  until: >
    (dv.resources | length) > 0 and
    (dv.resources[0].status is defined) and
    (dv.resources[0].status.phase | default('')) == "Succeeded"
  retries: "{{ dv_wait_retries | default(60) }}"
  delay: "{{ dv_wait_delay | default(20) }}"

- name: Wait | VM to reach a runnable state
  when: not ansible_check_mode
  kubernetes.core.k8s_info:
    kubeconfig: "{{ kubeconfig }}"
    api_version: kubevirt.io/v1
    kind: VirtualMachine
    name: "{{ vm_name }}"
    namespace: "{{ namespace }}"
  register: vm
  until: >
    (vm.resources | length) > 0 and
    (vm.resources[0].status is defined) and
    (vm.resources[0].status.printableStatus | default('')) in ["Running", "Paused", "Provisioning"]
  retries: "{{ vm_wait_retries | default(30) }}"
  delay: "{{ vm_wait_delay | default(10) }}"

# -------------------------
# 5) OUTPUT (runs in all modes)
# -------------------------

- name: Output | Summarize the result
  ansible.builtin.debug:
    msg:
      - "Namespace: {{ namespace }}"
      - "VM: {{ vm_name }}"
      - "CPU/Memory: {{ cpu_cores }} cores / {{ memory }}"
      - "Disk: {{ disk_size }} (SC='{{ storage_class | default('default', true) }}', mode='{{ volume_mode | default('unspecified', true) }}')"
      - "Image: {{ image_url }}"
      - "RunStrategy: {{ run_strategy }}"
      - "Note: In --check, no resources were created; see the Plan output above."
